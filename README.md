# ARMv7-Compatible Soft CPU - Cmod S7 + ESP32 Memory Controller + Cmod S6 IO Controller
## Project Overview

A 3-stage pipelined ARMv7-compatible processor implemented on the **Digilent Cmod S7-25**
FPGA, using an **ESP32 as external memory**. The CPU executes ARMv7-A instructions with
correct output behavior (ISA-accurate, not microarchitecture-accurate).

---

## Architecture

```
┌─────────────────────────────────────────────┐
│              Cmod S7-25 FPGA  (CPU1)        │
│                                             │
│  ┌──────────┐    ┌──────────┐               │
│  │  FETCH   │───>│  DECODE  │               │
│  │  Stage   │    │  Stage   │               │
│  └──────────┘    └───┬──────┘               │
│       ▲              │                      │
│       │         ┌────▼──────┐               │
│       │         │  EXECUTE  │               │
│       │         │  Stage    │               │
│       │         └────┬──────┘               │
│       │              │                      │
│  ┌────┴──────────────▼────┐        ┌─────┐  │
│  │      MEM BUS           │        | GND |  │
│  │  (handshake FSM)       │        └─────┘  │
│  └───────────────────────┬┘           |     │────┐
│                          │            |     │    |
└──────────────────────────┼────────────┼─────┘    |
                           │            |          |
                           │            |          |
┌──────────────────────────┼────────────┼─────┐    |
│         ESP32            │            |     │    |  ┌──────┐
│                          │            |     │    |  | UART |
|                          |            |     |    |  | RxTx |
│  ┌───────────────────────┴────┐    ┌─────┐  │    |  └──────┘
│  │  Memory Controller         │    | GND |  │    |
│  │  (65536 × 32-bit words)    │    └─────┘  │    |
│  │  = 256KB address space     │       |     │    |
│  └───────────────────────┼────┘       |     │    |
└──────────────────────────┼────────────|─────┘    |
                           |            |          |
┌──────────────────────────┼────────────┼─────┐    |
│         Cmod-S6          └─────┐      |     │    | 
│         ┌─────────────────┐    |      |     │    |  
│         |   Connects to   |    |      |     │    | 
│         |  all of the IO  |    |   ┌─────┐  |    |
|         |                 |    |   | GND |  │    |
│         |(Screen included)|    |   └─────┘  │    |
│         |                 |    |            │    |
│         └─────────────────┘────|────────────|────┘
└─────┼┼─────────────────────────┼────────────┘
      ||  I2C                    |
┌─────┼┼─────────────┐───────────┘ 80 bytes of memory for the screen from 0x0
|                    |
|      2004 LCD      |
|                    |
|                    |
└────────────────────┘
```

**On a higher level, here is how this works**  

![](/docs/imgs/Diagram.png)

---

### Memory map
| Start Address | End Address | Size (words) | Description |
| --- | --- | --- | ---  |
| 0x00000000    | 0x0003FFFF  | 256000       | This is the entire raw memory of the device |
| 0x00000000    | 0x00000050  | 80           | This is all of the data for the screen. |
| 0x0x00000051  | 0x | | Area of memeory dedicated to meta-data of devices on the device |


### Pipeline Stages
| Stage   | Description                                      |
|---------|--------------------------------------------------|
| FETCH   | Puts word address on bus, waits for ESP32 ACK   |
| DECODE  | Decodes instruction, reads registers, checks cond|
| EXECUTE | ALU op / branch / load-store, writes result back |

Memory accesses (LDR/STR) stall the pipeline until ESP32 responds.
Branches flush 2 pipeline stages (ARM PC+8 convention).

---

## Device structure
- 1 word for type of device (enum like)
- 1 word for the port it is connected to
- 1 word for the the 

---

## Loading Your ARM Program

### Toolchain setup
```bash
# Aarch based OS (like me)
sudo pacman -S arm-none-eabi-gcc arm-none-eabi-newlib arm-none-eabi-binutils

# Ubuntu/Debian
sudo apt install gcc-arm-none-eabi

# macOS
brew install arm-none-eabi-gcc
```

### Link script (link.ld)
This is just a super simple bare metal linker script just so all of the instructions are in the correct format.
```
SECTIONS {
    . = 0x00000000;
    .text : { *(.text) }
    .data : { *(.data) }
    .bss  : { *(.bss)  }
}
```

### Build and convert
```bash
arm-none-eabi-as -mcpu=cortex-a9 test.S -o test.o
arm-none-eabi-ld -T link.ld test.o -o test.elf
arm-none-eabi-objcopy -O binary test.elf test.bin

# Convert to C array for ESP32
xxd -i test.bin > program_data.h
```

### Load into ESP32
In `esp32_memory.ino`, replace `load_test_program()` with:
```cpp
#include "program_data.h"   // generated by xxd
void load_test_program() {
    memset(flash_mem, 0, sizeof(flash_mem));
    memcpy(flash_mem, test_bin, test_bin_len);
}
```

---

## Supported Instructions

| Class              | Instructions                                      | Status |
|--------------------|---------------------------------------------------|--------|
| Data Processing    | AND, EOR, SUB, RSB, ADD, ADC, SBC, RSC, ORR, BIC | YES |
| Move               | MOV, MVN                                          | YES |
| Compare            | TST, TEQ, CMP, CMN                                | YES |
| Branch             | B, BL, BX                                         | YES |
| Load/Store         | LDR, STR, LDRB, STRB (pre/post-index)            | YES |
| Load/Store Multiple| LDM, STM                                          | YES |
| Multiply           | MUL, MLA                                          | YES |
| Status Register    | MRS, MSR                                          | YES |
| Condition Codes    | EQ,NE,CS,CC,MI,PL,VS,VC,HI,LS,GE,LT,GT,LE,AL    | YES |
| Barrel Shifter     | LSL, LSR, ASR, ROR, RRX                           | YES |
| Long Multiply      | UMULL, SMULL, UMLAL, SMLAL                        | NO (NOP)|
| VFP/NEON           | Floating point                                    | NO     |
| Thumb              | 16-bit Thumb instructions                         | NO     |
| CP15               | Cache/MMU control                                 | NO     |

---

## CPSR Flags

| Bit | Flag | Meaning                    |
|-----|------|----------------------------|
| 31  | N    | Negative result            |
| 30  | Z    | Zero result                |
| 29  | C    | Carry out / borrow         |
| 28  | V    | Overflow (signed)          |
| 7   | I    | IRQ disable (set at reset) |
| 6   | F    | FIQ disable (set at reset) |
| 5   | T    | Thumb mode (always 0 here) |
| 4:0 | M   | Processor mode (SVC=10011) |

---

## Address Space

| Word Address | Byte Address      | Suggested Use         |
|--------------|-------------------|-----------------------|
| 0x0000–0x0FFF| 0x00000–0x0FFFF  | Code (16KB)           |
| 0x1000–0x1FFF| 0x10000–0x1FFFF  | Data (16KB)           |
| 0x2000–0x3FFF| 0x20000–0x3FFFF  | Stack (grows down)    |
| 0x4000–0xFFFF| 0x40000–0xFFFFF  | Extended / future use |

Initial SP: `0x0003FFFC`

---

## Debug Output (UART)

Connect to Cmod S7 USB at 115200 baud. Output example:
```
PC=00000000 F0
PC=00000004 F0
PC=00000008 F1     ← Z flag set
PC=00000004 F1
```
`F` nibble = `NZCV` (bit3=N, bit2=Z, bit1=C, bit0=V)

---

## Known Limitations

1. **No Thumb support** — assemble with `-marm` flag
2. **16-bit address bus** — 256KB max address space (word-addressed)
3. **Memory latency** — each access takes ~25–60 cycles (ESP32 GPIO speed)
4. **No interrupts** — IRQ/FIQ inputs not connected
5. **No cache** — every instruction fetch hits the ESP32
6. **Upper 16 data bits** — require GPIO expander for full 32-bit (see wiring note)
